'''
Neuron simulator export for:

Components:
    null (Type: notes)
    kslow (Type: ionChannelHH:  conductance=1.0E-11 (SI conductance))
    holderCell_min100 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=-0.1 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_min80 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=-0.08 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_min60 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=-0.06 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_min40 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=-0.04 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_min20 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=-0.02 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_0 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.0 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_20 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.02 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_40 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.04 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_60 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.06 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_80 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.08 (SI voltage) caConc=5.0E-5 (SI concentration))
    holderCell_100 (Type: vClampedCell:  delay=0.01 (SI time) duration=0.08 (SI time) baseVoltage=-0.07 (SI voltage) targetVoltage=0.1 (SI voltage) caConc=5.0E-5 (SI concentration))
    rampCell0 (Type: vClampedRampCell:  delay=0.0 (SI time) duration=0.2 (SI time) baseVoltage=-0.1 (SI voltage) targetVoltage0=-0.1 (SI voltage) targetVoltage1=0.3 (SI voltage) caConc=5.0E-5 (SI concentration))
    net1 (Type: networkWithTemperature:  temperature=310.15 (SI temperature))
    sim1 (Type: Simulation:  length=0.1 (SI time) step=2.5E-6 (SI time))


    This NEURON file has been generated by org.neuroml.export (see https://github.com/NeuroML/org.neuroml.export)
         org.neuroml.export  v1.8.1
         org.neuroml.model   v1.8.1
         jLEMS               v0.10.6

'''

import neuron

import time
import datetime
import sys

import hashlib
h = neuron.h
h.load_file("nrngui.hoc")

h("objref p")
h("p = new PythonObject()")

class NeuronSimulation():

    def __init__(self, tstop, dt, seed=123456789):

        print("\n    Starting simulation in NEURON of %sms generated from NeuroML2 model...\n"%tstop)

        self.setup_start = time.time()
        self.seed = seed
        self.randoms = []
        self.next_global_id = 0  # Used in Random123 classes for elements using random(), etc. 

        self.next_spiking_input_id = 0  # Used in Random123 classes for elements using random(), etc. 

        '''
        Adding simulation Component(id=sim1 type=Simulation) of network/component: net1 (Type: networkWithTemperature:  temperature=310.15 (SI temperature))
        
        '''

        # Temperature used for network: 310.15 K
        h.celsius = 310.15 - 273.15

        # ######################   Population: holderCellPop_min100
        print("Population holderCellPop_min100 contains 1 instance(s) of component: holderCell_min100 of type: vClampedCell")

        h(" {n_holderCellPop_min100 = 1} ")
        '''
        Population holderCellPop_min100 contains instances of Component(id=holderCell_min100 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_min100) in a mod file
        '''
        h(" create holderCellPop_min100[1]")
        h(" objectvar m_holderCell_min100_holderCellPop_min100[1] ")

        for i in range(int(h.n_holderCellPop_min100)):
            h.holderCellPop_min100[i].L = 10.0
            h.holderCellPop_min100[i](0.5).diam = 10.0
            h.holderCellPop_min100[i](0.5).cm = 318.31
            h.holderCellPop_min100[i].push()
            h(" holderCellPop_min100[%i]  { m_holderCell_min100_holderCellPop_min100[%i] = new holderCell_min100(0.5) } "%(i,i))

            h.m_holderCell_min100_holderCellPop_min100[i].delay = 10.0
            h.m_holderCell_min100_holderCellPop_min100[i].duration = 80.0
            h.m_holderCell_min100_holderCellPop_min100[i].baseVoltage = -70.0
            h.m_holderCell_min100_holderCellPop_min100[i].targetVoltage = -100.0
            h.m_holderCell_min100_holderCellPop_min100[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_min80
        print("Population holderCellPop_min80 contains 1 instance(s) of component: holderCell_min80 of type: vClampedCell")

        h(" {n_holderCellPop_min80 = 1} ")
        '''
        Population holderCellPop_min80 contains instances of Component(id=holderCell_min80 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_min80) in a mod file
        '''
        h(" create holderCellPop_min80[1]")
        h(" objectvar m_holderCell_min80_holderCellPop_min80[1] ")

        for i in range(int(h.n_holderCellPop_min80)):
            h.holderCellPop_min80[i].L = 10.0
            h.holderCellPop_min80[i](0.5).diam = 10.0
            h.holderCellPop_min80[i](0.5).cm = 318.31
            h.holderCellPop_min80[i].push()
            h(" holderCellPop_min80[%i]  { m_holderCell_min80_holderCellPop_min80[%i] = new holderCell_min80(0.5) } "%(i,i))

            h.m_holderCell_min80_holderCellPop_min80[i].delay = 10.0
            h.m_holderCell_min80_holderCellPop_min80[i].duration = 80.0
            h.m_holderCell_min80_holderCellPop_min80[i].baseVoltage = -70.0
            h.m_holderCell_min80_holderCellPop_min80[i].targetVoltage = -80.0
            h.m_holderCell_min80_holderCellPop_min80[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_min60
        print("Population holderCellPop_min60 contains 1 instance(s) of component: holderCell_min60 of type: vClampedCell")

        h(" {n_holderCellPop_min60 = 1} ")
        '''
        Population holderCellPop_min60 contains instances of Component(id=holderCell_min60 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_min60) in a mod file
        '''
        h(" create holderCellPop_min60[1]")
        h(" objectvar m_holderCell_min60_holderCellPop_min60[1] ")

        for i in range(int(h.n_holderCellPop_min60)):
            h.holderCellPop_min60[i].L = 10.0
            h.holderCellPop_min60[i](0.5).diam = 10.0
            h.holderCellPop_min60[i](0.5).cm = 318.31
            h.holderCellPop_min60[i].push()
            h(" holderCellPop_min60[%i]  { m_holderCell_min60_holderCellPop_min60[%i] = new holderCell_min60(0.5) } "%(i,i))

            h.m_holderCell_min60_holderCellPop_min60[i].delay = 10.0
            h.m_holderCell_min60_holderCellPop_min60[i].duration = 80.0
            h.m_holderCell_min60_holderCellPop_min60[i].baseVoltage = -70.0
            h.m_holderCell_min60_holderCellPop_min60[i].targetVoltage = -60.0
            h.m_holderCell_min60_holderCellPop_min60[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_min40
        print("Population holderCellPop_min40 contains 1 instance(s) of component: holderCell_min40 of type: vClampedCell")

        h(" {n_holderCellPop_min40 = 1} ")
        '''
        Population holderCellPop_min40 contains instances of Component(id=holderCell_min40 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_min40) in a mod file
        '''
        h(" create holderCellPop_min40[1]")
        h(" objectvar m_holderCell_min40_holderCellPop_min40[1] ")

        for i in range(int(h.n_holderCellPop_min40)):
            h.holderCellPop_min40[i].L = 10.0
            h.holderCellPop_min40[i](0.5).diam = 10.0
            h.holderCellPop_min40[i](0.5).cm = 318.31
            h.holderCellPop_min40[i].push()
            h(" holderCellPop_min40[%i]  { m_holderCell_min40_holderCellPop_min40[%i] = new holderCell_min40(0.5) } "%(i,i))

            h.m_holderCell_min40_holderCellPop_min40[i].delay = 10.0
            h.m_holderCell_min40_holderCellPop_min40[i].duration = 80.0
            h.m_holderCell_min40_holderCellPop_min40[i].baseVoltage = -70.0
            h.m_holderCell_min40_holderCellPop_min40[i].targetVoltage = -40.0
            h.m_holderCell_min40_holderCellPop_min40[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_min20
        print("Population holderCellPop_min20 contains 1 instance(s) of component: holderCell_min20 of type: vClampedCell")

        h(" {n_holderCellPop_min20 = 1} ")
        '''
        Population holderCellPop_min20 contains instances of Component(id=holderCell_min20 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_min20) in a mod file
        '''
        h(" create holderCellPop_min20[1]")
        h(" objectvar m_holderCell_min20_holderCellPop_min20[1] ")

        for i in range(int(h.n_holderCellPop_min20)):
            h.holderCellPop_min20[i].L = 10.0
            h.holderCellPop_min20[i](0.5).diam = 10.0
            h.holderCellPop_min20[i](0.5).cm = 318.31
            h.holderCellPop_min20[i].push()
            h(" holderCellPop_min20[%i]  { m_holderCell_min20_holderCellPop_min20[%i] = new holderCell_min20(0.5) } "%(i,i))

            h.m_holderCell_min20_holderCellPop_min20[i].delay = 10.0
            h.m_holderCell_min20_holderCellPop_min20[i].duration = 80.0
            h.m_holderCell_min20_holderCellPop_min20[i].baseVoltage = -70.0
            h.m_holderCell_min20_holderCellPop_min20[i].targetVoltage = -20.0
            h.m_holderCell_min20_holderCellPop_min20[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_0
        print("Population holderCellPop_0 contains 1 instance(s) of component: holderCell_0 of type: vClampedCell")

        h(" {n_holderCellPop_0 = 1} ")
        '''
        Population holderCellPop_0 contains instances of Component(id=holderCell_0 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_0) in a mod file
        '''
        h(" create holderCellPop_0[1]")
        h(" objectvar m_holderCell_0_holderCellPop_0[1] ")

        for i in range(int(h.n_holderCellPop_0)):
            h.holderCellPop_0[i].L = 10.0
            h.holderCellPop_0[i](0.5).diam = 10.0
            h.holderCellPop_0[i](0.5).cm = 318.31
            h.holderCellPop_0[i].push()
            h(" holderCellPop_0[%i]  { m_holderCell_0_holderCellPop_0[%i] = new holderCell_0(0.5) } "%(i,i))

            h.m_holderCell_0_holderCellPop_0[i].delay = 10.0
            h.m_holderCell_0_holderCellPop_0[i].duration = 80.0
            h.m_holderCell_0_holderCellPop_0[i].baseVoltage = -70.0
            h.m_holderCell_0_holderCellPop_0[i].targetVoltage = 0.0
            h.m_holderCell_0_holderCellPop_0[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_20
        print("Population holderCellPop_20 contains 1 instance(s) of component: holderCell_20 of type: vClampedCell")

        h(" {n_holderCellPop_20 = 1} ")
        '''
        Population holderCellPop_20 contains instances of Component(id=holderCell_20 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_20) in a mod file
        '''
        h(" create holderCellPop_20[1]")
        h(" objectvar m_holderCell_20_holderCellPop_20[1] ")

        for i in range(int(h.n_holderCellPop_20)):
            h.holderCellPop_20[i].L = 10.0
            h.holderCellPop_20[i](0.5).diam = 10.0
            h.holderCellPop_20[i](0.5).cm = 318.31
            h.holderCellPop_20[i].push()
            h(" holderCellPop_20[%i]  { m_holderCell_20_holderCellPop_20[%i] = new holderCell_20(0.5) } "%(i,i))

            h.m_holderCell_20_holderCellPop_20[i].delay = 10.0
            h.m_holderCell_20_holderCellPop_20[i].duration = 80.0
            h.m_holderCell_20_holderCellPop_20[i].baseVoltage = -70.0
            h.m_holderCell_20_holderCellPop_20[i].targetVoltage = 20.0
            h.m_holderCell_20_holderCellPop_20[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_40
        print("Population holderCellPop_40 contains 1 instance(s) of component: holderCell_40 of type: vClampedCell")

        h(" {n_holderCellPop_40 = 1} ")
        '''
        Population holderCellPop_40 contains instances of Component(id=holderCell_40 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_40) in a mod file
        '''
        h(" create holderCellPop_40[1]")
        h(" objectvar m_holderCell_40_holderCellPop_40[1] ")

        for i in range(int(h.n_holderCellPop_40)):
            h.holderCellPop_40[i].L = 10.0
            h.holderCellPop_40[i](0.5).diam = 10.0
            h.holderCellPop_40[i](0.5).cm = 318.31
            h.holderCellPop_40[i].push()
            h(" holderCellPop_40[%i]  { m_holderCell_40_holderCellPop_40[%i] = new holderCell_40(0.5) } "%(i,i))

            h.m_holderCell_40_holderCellPop_40[i].delay = 10.0
            h.m_holderCell_40_holderCellPop_40[i].duration = 80.0
            h.m_holderCell_40_holderCellPop_40[i].baseVoltage = -70.0
            h.m_holderCell_40_holderCellPop_40[i].targetVoltage = 40.0
            h.m_holderCell_40_holderCellPop_40[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_60
        print("Population holderCellPop_60 contains 1 instance(s) of component: holderCell_60 of type: vClampedCell")

        h(" {n_holderCellPop_60 = 1} ")
        '''
        Population holderCellPop_60 contains instances of Component(id=holderCell_60 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_60) in a mod file
        '''
        h(" create holderCellPop_60[1]")
        h(" objectvar m_holderCell_60_holderCellPop_60[1] ")

        for i in range(int(h.n_holderCellPop_60)):
            h.holderCellPop_60[i].L = 10.0
            h.holderCellPop_60[i](0.5).diam = 10.0
            h.holderCellPop_60[i](0.5).cm = 318.31
            h.holderCellPop_60[i].push()
            h(" holderCellPop_60[%i]  { m_holderCell_60_holderCellPop_60[%i] = new holderCell_60(0.5) } "%(i,i))

            h.m_holderCell_60_holderCellPop_60[i].delay = 10.0
            h.m_holderCell_60_holderCellPop_60[i].duration = 80.0
            h.m_holderCell_60_holderCellPop_60[i].baseVoltage = -70.0
            h.m_holderCell_60_holderCellPop_60[i].targetVoltage = 60.0
            h.m_holderCell_60_holderCellPop_60[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_80
        print("Population holderCellPop_80 contains 1 instance(s) of component: holderCell_80 of type: vClampedCell")

        h(" {n_holderCellPop_80 = 1} ")
        '''
        Population holderCellPop_80 contains instances of Component(id=holderCell_80 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_80) in a mod file
        '''
        h(" create holderCellPop_80[1]")
        h(" objectvar m_holderCell_80_holderCellPop_80[1] ")

        for i in range(int(h.n_holderCellPop_80)):
            h.holderCellPop_80[i].L = 10.0
            h.holderCellPop_80[i](0.5).diam = 10.0
            h.holderCellPop_80[i](0.5).cm = 318.31
            h.holderCellPop_80[i].push()
            h(" holderCellPop_80[%i]  { m_holderCell_80_holderCellPop_80[%i] = new holderCell_80(0.5) } "%(i,i))

            h.m_holderCell_80_holderCellPop_80[i].delay = 10.0
            h.m_holderCell_80_holderCellPop_80[i].duration = 80.0
            h.m_holderCell_80_holderCellPop_80[i].baseVoltage = -70.0
            h.m_holderCell_80_holderCellPop_80[i].targetVoltage = 80.0
            h.m_holderCell_80_holderCellPop_80[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: holderCellPop_100
        print("Population holderCellPop_100 contains 1 instance(s) of component: holderCell_100 of type: vClampedCell")

        h(" {n_holderCellPop_100 = 1} ")
        '''
        Population holderCellPop_100 contains instances of Component(id=holderCell_100 type=vClampedCell)
        whose dynamics will be implemented as a mechanism (holderCell_100) in a mod file
        '''
        h(" create holderCellPop_100[1]")
        h(" objectvar m_holderCell_100_holderCellPop_100[1] ")

        for i in range(int(h.n_holderCellPop_100)):
            h.holderCellPop_100[i].L = 10.0
            h.holderCellPop_100[i](0.5).diam = 10.0
            h.holderCellPop_100[i](0.5).cm = 318.31
            h.holderCellPop_100[i].push()
            h(" holderCellPop_100[%i]  { m_holderCell_100_holderCellPop_100[%i] = new holderCell_100(0.5) } "%(i,i))

            h.m_holderCell_100_holderCellPop_100[i].delay = 10.0
            h.m_holderCell_100_holderCellPop_100[i].duration = 80.0
            h.m_holderCell_100_holderCellPop_100[i].baseVoltage = -70.0
            h.m_holderCell_100_holderCellPop_100[i].targetVoltage = 100.0
            h.m_holderCell_100_holderCellPop_100[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        # ######################   Population: rampCellPop0
        print("Population rampCellPop0 contains 1 instance(s) of component: rampCell0 of type: vClampedRampCell")

        h(" {n_rampCellPop0 = 1} ")
        '''
        Population rampCellPop0 contains instances of Component(id=rampCell0 type=vClampedRampCell)
        whose dynamics will be implemented as a mechanism (rampCell0) in a mod file
        '''
        h(" create rampCellPop0[1]")
        h(" objectvar m_rampCell0_rampCellPop0[1] ")

        for i in range(int(h.n_rampCellPop0)):
            h.rampCellPop0[i].L = 10.0
            h.rampCellPop0[i](0.5).diam = 10.0
            h.rampCellPop0[i](0.5).cm = 318.31
            h.rampCellPop0[i].push()
            h(" rampCellPop0[%i]  { m_rampCell0_rampCellPop0[%i] = new rampCell0(0.5) } "%(i,i))

            h.m_rampCell0_rampCellPop0[i].delay = 0.0
            h.m_rampCell0_rampCellPop0[i].duration = 200.0
            h.m_rampCell0_rampCellPop0[i].baseVoltage = -100.0
            h.m_rampCell0_rampCellPop0[i].targetVoltage0 = -100.0
            h.m_rampCell0_rampCellPop0[i].targetVoltage1 = 300.0
            h.m_rampCell0_rampCellPop0[i].caConc = 5.0E-5
            h.pop_section()

            self.next_global_id+=1


        trec = h.Vector()
        trec.record(h._ref_t)

        h.tstop = tstop

        h.dt = dt

        h.steps_per_ms = 1/h.dt

        # ######################   Display: self.display_d0
        self.display_d0 = h.Graph(0)
        self.display_d0.size(0,h.tstop,-80.0,50.0)
        self.display_d0.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
        h.graphList[0].append(self.display_d0)
        # Line, plotting: holderCellPop_min100[0]/v
        self.display_d0.addexpr("m_holderCell_min100_holderCellPop_min100[0].v", "m_holderCell_min100_holderCellPop_min100[0].v", 1, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min80[0]/v
        self.display_d0.addexpr("m_holderCell_min80_holderCellPop_min80[0].v", "m_holderCell_min80_holderCellPop_min80[0].v", 2, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min60[0]/v
        self.display_d0.addexpr("m_holderCell_min60_holderCellPop_min60[0].v", "m_holderCell_min60_holderCellPop_min60[0].v", 3, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min40[0]/v
        self.display_d0.addexpr("m_holderCell_min40_holderCellPop_min40[0].v", "m_holderCell_min40_holderCellPop_min40[0].v", 4, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min20[0]/v
        self.display_d0.addexpr("m_holderCell_min20_holderCellPop_min20[0].v", "m_holderCell_min20_holderCellPop_min20[0].v", 5, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_0[0]/v
        self.display_d0.addexpr("m_holderCell_0_holderCellPop_0[0].v", "m_holderCell_0_holderCellPop_0[0].v", 6, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_20[0]/v
        self.display_d0.addexpr("m_holderCell_20_holderCellPop_20[0].v", "m_holderCell_20_holderCellPop_20[0].v", 7, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_40[0]/v
        self.display_d0.addexpr("m_holderCell_40_holderCellPop_40[0].v", "m_holderCell_40_holderCellPop_40[0].v", 8, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_60[0]/v
        self.display_d0.addexpr("m_holderCell_60_holderCellPop_60[0].v", "m_holderCell_60_holderCellPop_60[0].v", 9, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_80[0]/v
        self.display_d0.addexpr("m_holderCell_80_holderCellPop_80[0].v", "m_holderCell_80_holderCellPop_80[0].v", 10, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_100[0]/v
        self.display_d0.addexpr("m_holderCell_100_holderCellPop_100[0].v", "m_holderCell_100_holderCellPop_100[0].v", 1, 1, 0.8, 0.9, 2)

        # ######################   Display: self.display_d1
        self.display_d1 = h.Graph(0)
        self.display_d1.size(0,h.tstop,-80.0,50.0)
        self.display_d1.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
        h.graphList[0].append(self.display_d1)
        # Line, plotting: holderCellPop_min100[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_min100_holderCellPop_min100[0].test_kslow_fopen", "m_holderCell_min100_holderCellPop_min100[0].test_kslow_fopen", 1, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min80[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_min80_holderCellPop_min80[0].test_kslow_fopen", "m_holderCell_min80_holderCellPop_min80[0].test_kslow_fopen", 2, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min60[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_min60_holderCellPop_min60[0].test_kslow_fopen", "m_holderCell_min60_holderCellPop_min60[0].test_kslow_fopen", 3, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min40[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_min40_holderCellPop_min40[0].test_kslow_fopen", "m_holderCell_min40_holderCellPop_min40[0].test_kslow_fopen", 4, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min20[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_min20_holderCellPop_min20[0].test_kslow_fopen", "m_holderCell_min20_holderCellPop_min20[0].test_kslow_fopen", 5, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_0[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_0_holderCellPop_0[0].test_kslow_fopen", "m_holderCell_0_holderCellPop_0[0].test_kslow_fopen", 6, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_20[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_20_holderCellPop_20[0].test_kslow_fopen", "m_holderCell_20_holderCellPop_20[0].test_kslow_fopen", 7, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_40[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_40_holderCellPop_40[0].test_kslow_fopen", "m_holderCell_40_holderCellPop_40[0].test_kslow_fopen", 8, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_60[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_60_holderCellPop_60[0].test_kslow_fopen", "m_holderCell_60_holderCellPop_60[0].test_kslow_fopen", 9, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_80[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_80_holderCellPop_80[0].test_kslow_fopen", "m_holderCell_80_holderCellPop_80[0].test_kslow_fopen", 10, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_100[0]/test/kslow/fopen
        self.display_d1.addexpr("m_holderCell_100_holderCellPop_100[0].test_kslow_fopen", "m_holderCell_100_holderCellPop_100[0].test_kslow_fopen", 1, 1, 0.8, 0.9, 2)

        # ######################   Display: self.display_d7
        self.display_d7 = h.Graph(0)
        self.display_d7.size(0,h.tstop,-80.0,50.0)
        self.display_d7.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
        h.graphList[0].append(self.display_d7)
        # Line, plotting: holderCellPop_min100[0]/test/i
        self.display_d7.addexpr("m_holderCell_min100_holderCellPop_min100[0].test_i", "m_holderCell_min100_holderCellPop_min100[0].test_i", 1, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min80[0]/test/i
        self.display_d7.addexpr("m_holderCell_min80_holderCellPop_min80[0].test_i", "m_holderCell_min80_holderCellPop_min80[0].test_i", 2, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min60[0]/test/i
        self.display_d7.addexpr("m_holderCell_min60_holderCellPop_min60[0].test_i", "m_holderCell_min60_holderCellPop_min60[0].test_i", 3, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min40[0]/test/i
        self.display_d7.addexpr("m_holderCell_min40_holderCellPop_min40[0].test_i", "m_holderCell_min40_holderCellPop_min40[0].test_i", 4, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_min20[0]/test/i
        self.display_d7.addexpr("m_holderCell_min20_holderCellPop_min20[0].test_i", "m_holderCell_min20_holderCellPop_min20[0].test_i", 5, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_0[0]/test/i
        self.display_d7.addexpr("m_holderCell_0_holderCellPop_0[0].test_i", "m_holderCell_0_holderCellPop_0[0].test_i", 6, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_20[0]/test/i
        self.display_d7.addexpr("m_holderCell_20_holderCellPop_20[0].test_i", "m_holderCell_20_holderCellPop_20[0].test_i", 7, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_40[0]/test/i
        self.display_d7.addexpr("m_holderCell_40_holderCellPop_40[0].test_i", "m_holderCell_40_holderCellPop_40[0].test_i", 8, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_60[0]/test/i
        self.display_d7.addexpr("m_holderCell_60_holderCellPop_60[0].test_i", "m_holderCell_60_holderCellPop_60[0].test_i", 9, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_80[0]/test/i
        self.display_d7.addexpr("m_holderCell_80_holderCellPop_80[0].test_i", "m_holderCell_80_holderCellPop_80[0].test_i", 10, 1, 0.8, 0.9, 2)
        # Line, plotting: holderCellPop_100[0]/test/i
        self.display_d7.addexpr("m_holderCell_100_holderCellPop_100[0].test_i", "m_holderCell_100_holderCellPop_100[0].test_i", 1, 1, 0.8, 0.9, 2)

        # ######################   Display: self.display_a_inf
        self.display_a_inf = h.Graph(0)
        self.display_a_inf.size(0,h.tstop,-80.0,50.0)
        self.display_a_inf.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
        h.graphList[0].append(self.display_a_inf)
        # Line, plotting: rampCellPop0[0]/test/kslow/a/inf
        self.display_a_inf.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_a_inf", "m_rampCell0_rampCellPop0[0].test_kslow_a_inf", 1, 1, 0.8, 0.9, 2)
        # Line, plotting: rampCellPop0[0]/test/kslow/b/bb/inf
        self.display_a_inf.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_b_bb_inf", "m_rampCell0_rampCellPop0[0].test_kslow_b_bb_inf", 2, 1, 0.8, 0.9, 2)
        # Line, plotting: rampCellPop0[0]/test/kslow/b/bb1/inf
        self.display_a_inf.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_b_bb1_inf", "m_rampCell0_rampCellPop0[0].test_kslow_b_bb1_inf", 3, 1, 0.8, 0.9, 2)

        # ######################   Display: self.display_a_tau
        self.display_a_tau = h.Graph(0)
        self.display_a_tau.size(0,h.tstop,-80.0,50.0)
        self.display_a_tau.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
        h.graphList[0].append(self.display_a_tau)
        # Line, plotting: rampCellPop0[0]/test/kslow/a/tau
        self.display_a_tau.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_a_tau", "m_rampCell0_rampCellPop0[0].test_kslow_a_tau", 1, 1, 0.8, 0.9, 2)
        # Line, plotting: rampCellPop0[0]/test/kslow/b/bb/tau
        self.display_a_tau.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_b_bb_tau", "m_rampCell0_rampCellPop0[0].test_kslow_b_bb_tau", 2, 1, 0.8, 0.9, 2)
        # Line, plotting: rampCellPop0[0]/test/kslow/b/bb1/tau
        self.display_a_tau.addexpr("m_rampCell0_rampCellPop0[0].test_kslow_b_bb1_tau", "m_rampCell0_rampCellPop0[0].test_kslow_b_bb1_tau", 3, 1, 0.8, 0.9, 2)



        # ######################   File to save: kslow.a.tau.lems.dat (a_tau_of1)
        # Column: rampCellPop0[0]/test/kslow/a/tau
        h(' objectvar v_a_a_tau_of1 ')
        h(' { v_a_a_tau_of1 = new Vector() } ')
        h(' { v_a_a_tau_of1.record(&m_rampCell0_rampCellPop0[0].test_kslow_a_tau) } ')
        h.v_a_a_tau_of1.resize((h.tstop * h.steps_per_ms) + 1)

        # ######################   File to save: kslow.rampV.lems.dat (rampCellV)
        # Column: rampCellPop0[0]/v
        h(' objectvar v_v_rampCellV ')
        h(' { v_v_rampCellV = new Vector() } ')
        h(' { v_v_rampCellV.record(&m_rampCell0_rampCellPop0[0].v) } ')
        h.v_v_rampCellV.resize((h.tstop * h.steps_per_ms) + 1)

        # ######################   File to save: kslow.a.inf.lems.dat (a_inf_of1)
        # Column: rampCellPop0[0]/test/kslow/a/inf
        h(' objectvar v_a_a_inf_of1 ')
        h(' { v_a_a_inf_of1 = new Vector() } ')
        h(' { v_a_a_inf_of1.record(&m_rampCell0_rampCellPop0[0].test_kslow_a_inf) } ')
        h.v_a_a_inf_of1.resize((h.tstop * h.steps_per_ms) + 1)

        # ######################   File to save: time.dat (time)
        # Column: time
        h(' objectvar v_time ')
        h(' { v_time = new Vector() } ')
        h(' { v_time.record(&t) } ')
        h.v_time.resize((h.tstop * h.steps_per_ms) + 1)

        self.initialized = False

        self.sim_end = -1 # will be overwritten

        setup_end = time.time()
        self.setup_time = setup_end - self.setup_start
        print("Setting up the network to simulate took %f seconds"%(self.setup_time))

        h.nrncontrolmenu()


    def run(self):

        self.initialized = True
        sim_start = time.time()
        print("Running a simulation of %sms (dt = %sms; seed=%s)" % (h.tstop, h.dt, self.seed))

        try:
            h.run()
        except Exception as e:
            print("Exception running NEURON: %s" % (e))
            return


        self.sim_end = time.time()
        self.sim_time = self.sim_end - sim_start
        print("Finished NEURON simulation in %f seconds (%f mins)..."%(self.sim_time, self.sim_time/60.0))

        try:
            self.save_results()
        except Exception as e:
            print("Exception saving results of NEURON simulation: %s" % (e))
            return


    def advance(self):

        if not self.initialized:
            h.finitialize()
            self.initialized = True

        h.fadvance()


    ###############################################################################
    # Hash function to use in generation of random value
    # This is copied from NetPyNE: https://github.com/Neurosim-lab/netpyne/blob/master/netpyne/simFuncs.py
    ###############################################################################
    def _id32 (self,obj): 
        return int(hashlib.md5(obj.encode('utf-8')).hexdigest()[0:8],16)  # convert 8 first chars of md5 hash in base 16 to int


    ###############################################################################
    # Initialize the stim randomizer
    # This is copied from NetPyNE: https://github.com/Neurosim-lab/netpyne/blob/master/netpyne/simFuncs.py
    ###############################################################################
    def _init_stim_randomizer(self,rand, stimType, gid, seed): 
        #print("INIT STIM  %s; %s; %s; %s"%(rand, stimType, gid, seed))
        rand.Random123(self._id32(stimType), gid, seed)


    def save_results(self):

        print("Saving results at t=%s..."%h.t)

        if self.sim_end < 0: self.sim_end = time.time()

        self.display_d0.exec_menu("View = plot")
        self.display_d1.exec_menu("View = plot")
        self.display_d7.exec_menu("View = plot")
        self.display_a_inf.exec_menu("View = plot")
        self.display_a_tau.exec_menu("View = plot")

        # ######################   File to save: time.dat (time)
        py_v_time = [ t/1000 for t in h.v_time.to_python() ]  # Convert to Python list for speed...

        f_time_f2 = open('time.dat', 'w')
        num_points = len(py_v_time)  # Simulation may have been stopped before tstop...

        for i in range(num_points):
            f_time_f2.write('%f'% py_v_time[i])  # Save in SI units...
        f_time_f2.close()
        print("Saved data to: time.dat")

        # ######################   File to save: kslow.a.tau.lems.dat (a_tau_of1)
        py_v_a_a_tau_of1 = [ float(x  / 1000.0) for x in h.v_a_a_tau_of1.to_python() ]  # Convert to Python list for speed, variable has dim: time

        f_a_tau_of1_f2 = open('kslow.a.tau.lems.dat', 'w')
        num_points = len(py_v_time)  # Simulation may have been stopped before tstop...

        for i in range(num_points):
            f_a_tau_of1_f2.write('%e\t%e\t\n' % (py_v_time[i], py_v_a_a_tau_of1[i], ))
        f_a_tau_of1_f2.close()
        print("Saved data to: kslow.a.tau.lems.dat")

        # ######################   File to save: kslow.rampV.lems.dat (rampCellV)
        py_v_v_rampCellV = [ float(x  / 1000.0) for x in h.v_v_rampCellV.to_python() ]  # Convert to Python list for speed, variable has dim: voltage

        f_rampCellV_f2 = open('kslow.rampV.lems.dat', 'w')
        num_points = len(py_v_time)  # Simulation may have been stopped before tstop...

        for i in range(num_points):
            f_rampCellV_f2.write('%e\t%e\t\n' % (py_v_time[i], py_v_v_rampCellV[i], ))
        f_rampCellV_f2.close()
        print("Saved data to: kslow.rampV.lems.dat")

        # ######################   File to save: kslow.a.inf.lems.dat (a_inf_of1)
        py_v_a_a_inf_of1 = [ float(x ) for x in h.v_a_a_inf_of1.to_python() ]  # Convert to Python list for speed, variable has dim: none

        f_a_inf_of1_f2 = open('kslow.a.inf.lems.dat', 'w')
        num_points = len(py_v_time)  # Simulation may have been stopped before tstop...

        for i in range(num_points):
            f_a_inf_of1_f2.write('%e\t%e\t\n' % (py_v_time[i], py_v_a_a_inf_of1[i], ))
        f_a_inf_of1_f2.close()
        print("Saved data to: kslow.a.inf.lems.dat")

        save_end = time.time()
        save_time = save_end - self.sim_end
        print("Finished saving results in %f seconds"%(save_time))

        print("Done")

if __name__ == '__main__':

    ns = NeuronSimulation(tstop=100, dt=0.0025, seed=123456789)

    ns.run()

